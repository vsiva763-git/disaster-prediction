<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Wave Animation - Tsunami Early Warning</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1a2a47 50%, #0f2744 100%);
            min-height: 100vh;
            padding: 20px;
            color: #e2e8f0;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 40px;
        }

        h1 {
            font-size: 2.5em;
            background: linear-gradient(135deg, #60a5fa, #a78bfa);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #cbd5e1;
            font-size: 1.1em;
        }

        .controls {
            background: rgba(30, 41, 59, 0.6);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(148, 163, 184, 0.2);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 30px;
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        label {
            color: #cbd5e1;
            font-weight: 600;
        }

        input[type="range"] {
            width: 150px;
            cursor: pointer;
        }

        select {
            background: rgba(59, 130, 246, 0.1);
            color: #e2e8f0;
            border: 1px solid rgba(148, 163, 184, 0.3);
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
        }

        button {
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            color: white;
            border: none;
            padding: 10px 24px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 16px rgba(59, 130, 246, 0.4);
        }

        .wave-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .wave-panel {
            background: rgba(30, 41, 59, 0.6);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(148, 163, 184, 0.2);
            border-radius: 12px;
            padding: 20px;
            overflow: hidden;
        }

        .wave-panel h3 {
            color: #60a5fa;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .wave-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
            font-size: 0.9em;
        }

        .info-item {
            background: rgba(59, 130, 246, 0.1);
            padding: 8px;
            border-radius: 6px;
            border-left: 3px solid #3b82f6;
        }

        .info-label {
            color: #94a3b8;
            font-size: 0.8em;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .info-value {
            color: #e2e8f0;
            font-weight: 600;
            margin-top: 2px;
        }

        .canvas-container {
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.8), rgba(30, 58, 68, 0.8));
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 15px;
            position: relative;
        }

        canvas {
            display: block;
            width: 100%;
            height: auto;
        }

        .wave-legend {
            display: flex;
            gap: 15px;
            font-size: 0.85em;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
        }

        .stats-grid {
            background: rgba(30, 41, 59, 0.6);
            border: 1px solid rgba(148, 163, 184, 0.2);
            border-radius: 12px;
            padding: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            text-align: center;
        }

        .stat-label {
            color: #94a3b8;
            font-size: 0.85em;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.8em;
            font-weight: 700;
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .risk-badge {
            display: inline-block;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.75em;
            font-weight: 700;
            text-transform: uppercase;
            margin-top: 8px;
        }

        .risk-low {
            background: rgba(16, 185, 129, 0.2);
            color: #4ade80;
        }

        .risk-moderate {
            background: rgba(249, 115, 22, 0.2);
            color: #fb923c;
        }

        .risk-high {
            background: rgba(239, 68, 68, 0.2);
            color: #f87171;
        }

        .animation-type-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .animation-btn {
            padding: 8px 16px;
            background: rgba(59, 130, 246, 0.2);
            border: 2px solid rgba(59, 130, 246, 0.4);
            color: #60a5fa;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .animation-btn.active {
            background: rgba(59, 130, 246, 0.5);
            border-color: #3b82f6;
            box-shadow: 0 0 12px rgba(59, 130, 246, 0.3);
        }

        .animation-btn:hover {
            background: rgba(59, 130, 246, 0.4);
            border-color: #3b82f6;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.8em;
            }

            .wave-grid {
                grid-template-columns: 1fr;
            }

            .stats-grid {
                grid-template-columns: 1fr 1fr;
            }

            .controls {
                flex-direction: column;
                gap: 12px;
            }

            .control-group {
                width: 100%;
                justify-content: space-between;
            }
        }

        .timestamp {
            text-align: center;
            color: #94a3b8;
            font-size: 0.85em;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üåä Advanced Wave Visualization</h1>
            <p class="subtitle">Real-time Tsunami Wave Animation & Analysis</p>
        </header>

        <div class="controls">
            <div class="control-group">
                <label for="waveAmplitude">Amplitude:</label>
                <input type="range" id="waveAmplitude" min="1" max="10" value="3" step="0.5">
                <span id="amplitudeValue">3.0</span>
            </div>
            
            <div class="control-group">
                <label for="waveFrequency">Frequency:</label>
                <input type="range" id="waveFrequency" min="0.5" max="3" value="1.5" step="0.1">
                <span id="frequencyValue">1.5</span>
            </div>

            <div class="control-group">
                <label for="waveSpeed">Speed:</label>
                <input type="range" id="waveSpeed" min="0.5" max="3" value="1.5" step="0.1">
                <span id="speedValue">1.5x</span>
            </div>

            <button onclick="toggleAnimation()">‚èØÔ∏è Toggle Animation</button>
            <button onclick="resetWaves()">üîÑ Reset</button>
        </div>

        <div class="animation-type-selector">
            <button class="animation-btn active" onclick="setAnimationType('smooth')">üåä Smooth Waves</button>
            <button class="animation-btn" onclick="setAnimationType('turbulent')">‚ö° Turbulent</button>
            <button class="animation-btn" onclick="setAnimationType('particle')">‚ú® Particle Flow</button>
            <button class="animation-btn" onclick="setAnimationType('spectral')">üé® Spectral</button>
        </div>

        <div class="wave-grid" id="waveGrid"></div>

        <div class="stats-grid" id="statsGrid"></div>

        <div class="timestamp" id="timestamp"></div>
    </div>

    <script>
        // Configuration
        const regions = [
            {
                id: 'arabian',
                name: 'Arabian Sea',
                color: '#3498db',
                gradient: ['#1e3c72', '#2a5298', '#3498db', '#1e3c72'],
                baseFreq: 0.05,
                amplitude: 40
            },
            {
                id: 'bengal',
                name: 'Bay of Bengal',
                color: '#2ecc71',
                gradient: ['#1e5631', '#2d6a4f', '#2ecc71', '#1e5631'],
                baseFreq: 0.055,
                amplitude: 45
            },
            {
                id: 'andaman',
                name: 'Andaman Sea',
                color: '#e67e22',
                gradient: ['#5e3c1c', '#8b4513', '#e67e22', '#5e3c1c'],
                baseFreq: 0.06,
                amplitude: 35
            }
        ];

        let animationState = {
            isRunning: true,
            time: 0,
            amplitude: 3,
            frequency: 1.5,
            speed: 1.5,
            type: 'smooth'
        };

        let waveData = {
            arabian: { maxHeight: 4.2, riskLevel: 'low', dataPoints: [] },
            bengal: { maxHeight: 5.1, riskLevel: 'moderate', dataPoints: [] },
            andaman: { maxHeight: 3.8, riskLevel: 'low', dataPoints: [] }
        };

        // Initialize canvas and animation
        function init() {
            createWavePanels();
            createStatsPanels();
            updateControlValues();
            animate();
        }

        function createWavePanels() {
            const grid = document.getElementById('waveGrid');
            grid.innerHTML = '';

            regions.forEach(region => {
                const panel = document.createElement('div');
                panel.className = 'wave-panel';
                panel.innerHTML = `
                    <h3>${region.name}</h3>
                    <div class="wave-info">
                        <div class="info-item">
                            <div class="info-label">Max Height</div>
                            <div class="info-value" id="height-${region.id}">--</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">Risk Level</div>
                            <div class="info-value" id="risk-${region.id}">--</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">Wave Period</div>
                            <div class="info-value" id="period-${region.id}">--</div>
                        </div>
                        <div class="info-item">
                            <div class="info-label">Speed</div>
                            <div class="info-value" id="speed-${region.id}">--</div>
                        </div>
                    </div>
                    <div class="canvas-container">
                        <canvas id="canvas-${region.id}" width="400" height="250"></canvas>
                    </div>
                    <div class="wave-legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: ${region.color};"></div>
                            <span>Water Surface</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: rgba(148, 163, 184, 0.3);"></div>
                            <span>Depth</span>
                        </div>
                    </div>
                `;
                grid.appendChild(panel);
            });
        }

        function createStatsPanels() {
            const grid = document.getElementById('statsGrid');
            grid.innerHTML = '';

            const stats = [
                { label: 'Global Max Height', id: 'globalMax', value: '0.0m' },
                { label: 'Average Risk', id: 'avgRisk', value: 'LOW' },
                { label: 'Monitoring Regions', id: 'regions', value: '3' },
                { label: 'Real-time Status', id: 'status', value: 'ACTIVE' }
            ];

            stats.forEach(stat => {
                const card = document.createElement('div');
                card.className = 'stat-card';
                card.innerHTML = `
                    <div class="stat-label">${stat.label}</div>
                    <div class="stat-value" id="stat-${stat.id}">${stat.value}</div>
                `;
                grid.appendChild(card);
            });
        }

        function updateControlValues() {
            document.getElementById('amplitudeValue').textContent = animationState.amplitude.toFixed(1);
            document.getElementById('frequencyValue').textContent = animationState.frequency.toFixed(1);
            document.getElementById('speedValue').textContent = (animationState.speed).toFixed(1) + 'x';
        }

        // Wave drawing functions for different animation types
        function drawSmoothWaves(ctx, region, time, width, height) {
            ctx.clearRect(0, 0, width, height);

            // Draw gradient background (water depth)
            const bgGradient = ctx.createLinearGradient(0, 0, 0, height);
            bgGradient.addColorStop(0, 'rgba(30, 58, 68, 0.3)');
            bgGradient.addColorStop(1, 'rgba(15, 23, 42, 0.8)');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, width, height);

            // Draw multiple wave layers
            const waveCount = 3;
            for (let w = 0; w < waveCount; w++) {
                const amplitude = (animationState.amplitude * region.amplitude) / (waveCount - w);
                const frequency = animationState.frequency * region.baseFreq;
                const phaseShift = w * 0.5;

                ctx.beginPath();
                ctx.moveTo(0, height / 2);

                for (let x = 0; x <= width; x += 1) {
                    const y = height / 2 + 
                        Math.sin((x / width * Math.PI * 2 * frequency) + (time * animationState.speed) + phaseShift) * amplitude +
                        Math.sin((x / width * Math.PI * 4 * frequency * 0.5) + (time * animationState.speed * 0.7)) * (amplitude * 0.5);
                    
                    if (x === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }

                ctx.lineTo(width, height);
                ctx.lineTo(0, height);
                ctx.closePath();

                const waveGradient = ctx.createLinearGradient(0, 0, 0, height);
                const alpha = 0.7 - (w * 0.15);
                waveGradient.addColorStop(0, region.color + Math.floor(alpha * 255).toString(16).padStart(2, '0'));
                waveGradient.addColorStop(1, region.color + '33');
                ctx.fillStyle = waveGradient;
                ctx.fill();
            }

            // Draw surface line
            ctx.strokeStyle = region.color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            const amplitude = animationState.amplitude * region.amplitude;
            const frequency = animationState.frequency * region.baseFreq;

            for (let x = 0; x <= width; x += 2) {
                const y = height / 2 + 
                    Math.sin((x / width * Math.PI * 2 * frequency) + (time * animationState.speed)) * amplitude +
                    Math.sin((x / width * Math.PI * 4 * frequency * 0.5) + (time * animationState.speed * 0.7)) * (amplitude * 0.5);
                
                if (x === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
        }

        function drawTurbulentWaves(ctx, region, time, width, height) {
            ctx.clearRect(0, 0, width, height);

            const bgGradient = ctx.createLinearGradient(0, 0, 0, height);
            bgGradient.addColorStop(0, 'rgba(30, 58, 68, 0.4)');
            bgGradient.addColorStop(1, 'rgba(15, 23, 42, 0.9)');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, width, height);

            // Draw turbulent waves with multiple frequencies
            const amplitude = animationState.amplitude * region.amplitude;
            ctx.beginPath();
            ctx.moveTo(0, height / 2);

            for (let x = 0; x <= width; x += 1) {
                let y = height / 2;
                
                // Multiple sine waves with different frequencies for turbulence
                for (let freq = 0.03; freq <= 0.15; freq += 0.02) {
                    y += Math.sin((x / width * Math.PI * 2 * freq) + (time * animationState.speed)) * 
                         amplitude * (0.2 + Math.random() * 0.2);
                }

                if (x === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }

            ctx.lineTo(width, height);
            ctx.lineTo(0, height);
            ctx.closePath();

            const waveGradient = ctx.createLinearGradient(0, 0, 0, height);
            waveGradient.addColorStop(0, region.color + 'b3');
            waveGradient.addColorStop(1, region.color + '33');
            ctx.fillStyle = waveGradient;
            ctx.fill();

            // Draw surface with more detail
            ctx.strokeStyle = region.color;
            ctx.lineWidth = 2.5;
            ctx.beginPath();
            
            for (let x = 0; x <= width; x += 1) {
                let y = height / 2;
                for (let freq = 0.03; freq <= 0.15; freq += 0.02) {
                    y += Math.sin((x / width * Math.PI * 2 * freq) + (time * animationState.speed)) * 
                         amplitude * (0.2 + Math.sin(time + x) * 0.15);
                }
                
                if (x === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
        }

        function drawParticleFlowWaves(ctx, region, time, width, height) {
            ctx.clearRect(0, 0, width, height);

            const bgGradient = ctx.createLinearGradient(0, 0, 0, height);
            bgGradient.addColorStop(0, 'rgba(30, 58, 68, 0.5)');
            bgGradient.addColorStop(1, 'rgba(15, 23, 42, 1)');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, width, height);

            // Draw wave
            const amplitude = animationState.amplitude * region.amplitude;
            const frequency = animationState.frequency * region.baseFreq;
            
            ctx.beginPath();
            for (let x = 0; x <= width; x += 2) {
                const y = height / 2 + Math.sin((x / width * Math.PI * 2 * frequency) + (time * animationState.speed)) * amplitude;
                if (x === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.lineTo(width, height);
            ctx.lineTo(0, height);
            ctx.closePath();

            const waveGradient = ctx.createLinearGradient(0, 0, 0, height);
            waveGradient.addColorStop(0, region.color + '99');
            waveGradient.addColorStop(1, region.color + '11');
            ctx.fillStyle = waveGradient;
            ctx.fill();

            // Draw particles
            ctx.fillStyle = region.color;
            ctx.globalAlpha = 0.6;
            for (let i = 0; i < 30; i++) {
                const x = (time * animationState.speed * 50 + i * 15) % width;
                const baseY = height / 2 + Math.sin((x / width * Math.PI * 2 * frequency) + (time * animationState.speed)) * amplitude;
                const particleY = baseY + Math.sin(time * 2 + i) * 10;
                
                const size = 2 + Math.sin(time + i) * 1.5;
                ctx.beginPath();
                ctx.arc(x, particleY, size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;

            // Surface line
            ctx.strokeStyle = region.color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let x = 0; x <= width; x += 1) {
                const y = height / 2 + Math.sin((x / width * Math.PI * 2 * frequency) + (time * animationState.speed)) * amplitude;
                if (x === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
        }

        function drawSpectralWaves(ctx, region, time, width, height) {
            ctx.clearRect(0, 0, width, height);

            const bgGradient = ctx.createLinearGradient(0, 0, 0, height);
            bgGradient.addColorStop(0, 'rgba(30, 58, 68, 0.3)');
            bgGradient.addColorStop(0.5, 'rgba(20, 40, 60, 0.5)');
            bgGradient.addColorStop(1, 'rgba(15, 23, 42, 0.9)');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, width, height);

            const amplitude = animationState.amplitude * region.amplitude;
            const frequency = animationState.frequency * region.baseFreq;

            // Draw spectral layers
            const spectrumSteps = 8;
            for (let step = spectrumSteps; step > 0; step--) {
                const alpha = step / spectrumSteps;
                const hueShift = (time * 0.5 + step * 0.1) % 1;
                
                ctx.beginPath();
                for (let x = 0; x <= width; x += 2) {
                    const y = height / 2 + 
                        Math.sin((x / width * Math.PI * 2 * frequency) + (time * animationState.speed) + step * 0.3) * amplitude * (step / spectrumSteps);
                    
                    if (x === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.lineTo(width, height);
                ctx.lineTo(0, height);
                ctx.closePath();

                // Create rainbow-like gradient
                const hue = (180 + hueShift * 360) % 360;
                const saturation = 70 + step * 5;
                ctx.fillStyle = `hsla(${hue}, ${saturation}%, 50%, ${alpha * 0.3})`;
                ctx.fill();
            }

            // Draw rainbow surface
            ctx.lineWidth = 3;
            for (let i = 0; i < 5; i++) {
                const offset = (time * 0.3 + i * 0.2) % 1;
                const hue = (offset * 360 + 180) % 360;
                ctx.strokeStyle = `hsl(${hue}, 100%, 50%)`;
                
                ctx.beginPath();
                for (let x = i; x <= width; x += 5) {
                    const y = height / 2 + Math.sin((x / width * Math.PI * 2 * frequency) + (time * animationState.speed)) * amplitude;
                    if (x === i) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
        }

        function drawWaves(time) {
            regions.forEach(region => {
                const canvas = document.getElementById(`canvas-${region.id}`);
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                const width = canvas.offsetWidth;
                const height = canvas.offsetHeight;

                canvas.width = width;
                canvas.height = height;

                switch (animationState.type) {
                    case 'smooth':
                        drawSmoothWaves(ctx, region, time, width, height);
                        break;
                    case 'turbulent':
                        drawTurbulentWaves(ctx, region, time, width, height);
                        break;
                    case 'particle':
                        drawParticleFlowWaves(ctx, region, time, width, height);
                        break;
                    case 'spectral':
                        drawSpectralWaves(ctx, region, time, width, height);
                        break;
                }
            });
        }

        function updateWaveData(time) {
            regions.forEach(region => {
                const amplitude = animationState.amplitude * region.amplitude;
                const frequency = animationState.frequency * region.baseFreq;
                
                // Calculate current wave height
                const waveHeight = Math.abs(Math.sin((time * animationState.speed) + region.baseFreq) * amplitude);
                const maxHeight = (amplitude / region.amplitude) * 10;
                
                // Calculate wave period (in seconds)
                const period = (2 * Math.PI) / (frequency * animationState.frequency);
                
                // Calculate speed (arbitrary units)
                const speed = (animationState.speed * frequency * 10).toFixed(1);
                
                // Determine risk level based on height
                let riskLevel = 'LOW';
                let riskClass = 'risk-low';
                if (waveHeight > amplitude * 0.7) {
                    riskLevel = 'HIGH';
                    riskClass = 'risk-high';
                } else if (waveHeight > amplitude * 0.4) {
                    riskLevel = 'MODERATE';
                    riskClass = 'risk-moderate';
                }

                document.getElementById(`height-${region.id}`).textContent = maxHeight.toFixed(1) + 'm';
                document.getElementById(`risk-${region.id}`).innerHTML = `<span class="risk-badge ${riskClass}">${riskLevel}</span>`;
                document.getElementById(`period-${region.id}`).textContent = period.toFixed(1) + 's';
                document.getElementById(`speed-${region.id}`).textContent = speed + ' m/s';

                waveData[region.id].maxHeight = maxHeight;
                waveData[region.id].riskLevel = riskLevel;
            });

            // Update global stats
            const maxHeights = Object.values(waveData).map(w => w.maxHeight);
            const globalMax = Math.max(...maxHeights);
            document.getElementById('stat-globalMax').textContent = globalMax.toFixed(1) + 'm';

            const avgRisk = calculateAverageRisk();
            document.getElementById('stat-avgRisk').textContent = avgRisk;

            document.getElementById('stat-status').textContent = animationState.isRunning ? 'üü¢ ACTIVE' : '‚è∏Ô∏è PAUSED';

            // Update timestamp
            const now = new Date();
            document.getElementById('timestamp').textContent = `Last updated: ${now.toLocaleTimeString()}`;
        }

        function calculateAverageRisk() {
            const risks = Object.values(waveData).map(w => {
                if (w.riskLevel === 'HIGH') return 3;
                if (w.riskLevel === 'MODERATE') return 2;
                return 1;
            });
            const avg = risks.reduce((a, b) => a + b) / risks.length;
            
            if (avg > 2.3) return 'üî¥ HIGH';
            if (avg > 1.5) return 'üü† MODERATE';
            return 'üü¢ LOW';
        }

        function animate() {
            if (animationState.isRunning) {
                animationState.time += 0.016; // Approximately 60 FPS
                drawWaves(animationState.time);
                updateWaveData(animationState.time);
            }
            requestAnimationFrame(animate);
        }

        // Control functions
        function toggleAnimation() {
            animationState.isRunning = !animationState.isRunning;
        }

        function resetWaves() {
            animationState.time = 0;
        }

        function setAnimationType(type) {
            animationState.type = type;
            
            document.querySelectorAll('.animation-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
        }

        // Event listeners
        document.getElementById('waveAmplitude').addEventListener('input', (e) => {
            animationState.amplitude = parseFloat(e.target.value);
            updateControlValues();
        });

        document.getElementById('waveFrequency').addEventListener('input', (e) => {
            animationState.frequency = parseFloat(e.target.value);
            updateControlValues();
        });

        document.getElementById('waveSpeed').addEventListener('input', (e) => {
            animationState.speed = parseFloat(e.target.value);
            updateControlValues();
        });

        // Initialize on page load
        window.addEventListener('load', init);
    </script>
</body>
</html>
